
遊戲名稱：《死靈召魂象棋》（DeadNecroChess）
核心玩法：2 人回合制象棋變體 + 靈魂附魔 + HP 射擊 + 屍骸循環 + 墳場掠奪
規則已定稿 v1.0（HackMD 文件已整理）
美術方向：極簡 CSS 原生 + 少量卡片圖片，暫不大量依賴外部素材
開發階段：一人開發 + 朋友小團體測試，尚未正式動工（幾天後開工才有環境）

技術路線（目前實作狀態）

前端：Vue 3 + Vite + Pinia + TypeScript（無 Tailwind，純 CSS scoped）
後端：Vercel Serverless Functions（api/ 目錄）+ Supabase PostgreSQL（rooms 資料表）
部署：已部署至 Vercel，具備正式 domain，支援單機/PVP/PVE/線上對戰四種模式
同步機制：Realtime WebSocket（Supabase）+ 4 秒輪詢 Hybrid Adapter（雙保險）
資源處理：圖片放 public/assets/cards/，靈魂卡資料以 JSON 驅動（souls/*.json）
資料持久化：線上對戰使用 Supabase 持久化 state_json；單機模式無持久化

已確認的頁面結構（第一版 MVP）

首頁（Landing）→ 主題介紹 + 開始遊戲 / 瀏覽牌庫 / 教學按鈕
牌庫展示頁 → 驗證所有卡牌（你自己最常用）
教學 / 規則頁 → 完整規則說明（HackMD 內容直接用）
創建 / 加入房間頁 → 輸入房間 ID 或建立新房間
遊戲戰鬥頁 → 核心畫面（棋盤 + 手牌 + 資源 + 階段切換）
遊戲結束 / 結算頁 → 勝負顯示 + 返回大廳
（可選）遊戲內小菜單 → 投降 / 返回 / 規則 / 設定

關鍵機制已確定

狀態同步：伺服器權威 + Socket.IO 全狀態廣播
重新同步：需 API（GET /api/game/:roomId/state） + Socket.IO requestState
斷線重連：visibilitychange + localStorage roomId + 自動同步
結束條件：投降 / 帥耐久歸零 / 長時間無行動自動投降
特效方向：先純 CSS + Canvas（翻牌、粒子、傷害飛出），後期可加 PixiJS

目前最容易遺忘 / 容易卡住的點（開工前提醒）

Git repo 是否已建立（建議用 GitLab public repo）
Render 帳號是否已註冊並授權 GitHub
Node.js 版本（建議 20 LTS）
Electron 打包流程是否已跑通（dev / build）
souls.json 是否先寫 5–10 張（至少跑通卡牌顯示）
棋盤座標系統先定義好（a1～i10 或 0,0～8,9）
第一個測試目標：兩人進房間能互相看到「移動棋子」

---

## 目前進度（實作狀態摘要）

### 引擎核心
- Engine 具備完整 reducer + guards + ShotPlan 執行架構（TypeScript）。
- 引擎測試（Vitest）目前全綠，每次變更均跑完整測試套件驗證。

### 氏族與卡牌
- **4 個氏族**全數實作完成並納入預設卡池：暗月影刃、冥河焰巫、永夜骸骨、鐵衛軍魂。
- 靈魂卡資料完全以 JSON 驅動（`src/data/souls/*.json`），abilities schema 支援多種 type（IGNORE_BLOCKING、CHAIN、PIERCE、ARMY_RALLY、LOGISTICS_REVIVE、SOLDIERS_TIERED_* 等）。
- 鐵衛氏族【軍勢】條件判斷、【軍援】追加攻擊、【整編】/【後勤】免費復活均已實作。

### 道具系統
- 道具卡完整實作：`USE_ITEM_FROM_HAND` action + 8 張道具各自效果引擎邏輯。
- 道具使用 UI 已整合至 Game.vue（有目標選擇模式、確認彈窗、二選一 UI for 骸骨煉化）。
- 死靈術 flags（itemNecroBonus、freeShootBonus、lastStandContractBonus 等）均在 NEXT_PHASE 時自動重置。

### UI / UX
- 射擊 UX 為「preview-first」：點目標後不立即射擊，必須明確 Confirm（Enter）。
- 多目標效果（貫通/波及/連鎖）棋盤即時標記，可拖拉操作選單避免遮擋。
- 獻祭操作使用棋盤浮動選單，確認彈窗出現時自動隱藏。
- 能力啟動 FX：`ABILITY_TRIGGERED` 事件 → 浮字 + 紫藍高亮。
- EffectsModal 顯示靈魂卡 text 描述（附魔能力一覽）。
- 回合背景漸層與棋盤 box-shadow 依紅/綠方切換顯示。
- Intro 頁靈魂卡以氏族頁簽切換呈現（wrapping grid，與道具卡相同排版風格）。
- Graveyard 顯示改為折疊/下拉（避免長 id 造成溢出）。

### Bot / 訓練
- `balanceBot.ts` 實作 epsilon-greedy 決策（buy/necro/combat 三階段）。
- `botWeights.ts` 含 BASE_WEIGHTS / DYNAMIC_WEIGHTS / OPPONENT_WEIGHTS，`getMergedWeights()` 支援 base/dynamic/blend/opponent 模式。
- 自動訓練腳本（`npm run train`）：多輪自對局 → 產生 balanceReport JSON → `updateDynamicWeights.js` 用 Wilson CI + momentum 更新 DYNAMIC_WEIGHTS。
- 訓練機制完全卡牌無關（`listSoulCards()` 自動包含所有已啟用氏族），鐵衛氏族已自動納入訓練並產生動態權重。
- Bot 具備鐵衛氏族意識：買牌偏好由訓練權重驅動；necro 階段會嘗試 LOGISTICS_REVIVE 免費復活卒；偏好在有 tiered aura 存在時多保留卒屍骸。

### 線上對戰
- **已完成 MVP**：Vercel Serverless API（create/join/action/state）+ Supabase 持久化。
- 權威伺服器模式：所有 action 由伺服器執行 canDispatch + reduce，再回傳 events。
- 隨機分邊（red/black）與先手於建立房間時由伺服器決定。
- Hybrid Adapter：Supabase Realtime WebSocket 即時觸發 + 4 秒輪詢雙保險，確保連線穩定。
- `_lastEvents` 儲存於 state_json，對手拉取時解包為 `pollEvents`，避免雙方重複觸發己方事件。
- 斷線重連：localStorage 保存 roomId/side/secret，重開頁面自動恢復。

### 氏族選擇
- 建立房間（線上/PVP/PVE）時均可選擇啟用氏族（至少 1 個），不選預設全開。
- 選擇介面整合於 Home.vue 的建房/開局流程中。
- 開局 splash 畫面顯示玩家顏色（你是RED/BLACK）及本場已啟用的氏族列表。

### 事件紀錄（EventList）
- 線上對戰中，對手的行動事件（買牌、移動、射擊等）透過 `pollEvents` 推送至事件紀錄。
- 所有引擎事件均轉換為可讀中文文字（`eventToText()` 函數）。
- 新增 `SOUL_BOUGHT` 引擎事件，記錄買牌來源（盲抽/展示/盜取）與卡名。

### 部署
- 已部署至 Vercel，具備正式 domain，可供朋友直接訪問線上對戰測試。
- api/ 目錄內引擎在 build 時自動編譯為 CJS（`api/_engine/`），Vercel 部署自動識別。

---

## 下一步（建議優先順序）

1. **道具卡擴充**：目前實作 8 張核心道具。剩餘規則文件內的道具卡（靈魂收割者、死亡連鎖、冥鎖封印、牢籠掠奪、棘荊領域、靈魂剝離針、靈魂觀星儀、冥界稅收）視需求逐步實作。
2. **更多氏族**：血契狂徒血脈、緯度界標（規則文件已有設計草稿）。
3. **Bot 強化**：更細緻的戰鬥行動評分（攻守評估、宮格安全性）；可選：用 MCTS 替換 epsilon-greedy。
4. **氏族能力持續資料驅動化**：逐步將剩餘 hardcode 邏輯移入 ability schema（目前暗月越境、冥河冥雷等仍部分 hardcode）。
5. **線上對戰體驗優化**：投降功能、觀戰模式、房間過期清理、對局歷史記錄。

---

## 線上對戰架構（已實作）

### 實際架構（Vercel + Supabase）

- **Supabase `rooms` 資料表**：`id, red_secret, black_secret, state_json, version, status, updated_at`
- **API 端點**（Vercel Serverless）：
  - `POST /api/rooms/create`：建立房間，隨機分邊與先手，回傳 `{ roomId, secret, side }`
  - `POST /api/rooms/:roomId/join`：加入房間，取得另一側，回傳 `{ roomId, secret, side }`
  - `POST /api/rooms/:roomId/action`：送出 action，伺服器執行 canDispatch + reduce，更新 state_json
  - `GET /api/rooms/:roomId/state?since=N`：拉取最新 state（版本未變則 304）

### 同步策略（Hybrid Adapter）

- **Realtime**：Supabase WebSocket，監聽 rooms 表 version 欄位變化，即時觸發 fetchState
- **Polling fallback**：每 4 秒輪詢一次作為保底（Realtime 不穩時自動補位）
- 兩者同時運行，`_fetchState()` 內有版本號 de-dup，不會重複處理

### 事件傳播

- 伺服器 action handler 將 `result.events` 存入 `state_json._lastEvents`
- 對手拉取 state 時，client 端從 `_lastEvents` 解包為 `pollEvents`
- `_suppressPollEvents` flag 防止己方 sendAction 後誤把自己的 events 重複播放

### 斷線重連

- localStorage 保存 `{ roomId, side, secret }`
- 重開頁面自動呼叫 `reconnect()`，重新 fetch 最新 state 並啟動 adapter

---

## Electron 打包成 App：可行性評估

### 可行性

- 可行（Vue3/Vite + Electron 是常見組合）。
- 對本專案最大價值：
  - 離線資源打包（卡圖/音效）
  - 桌面快捷啟動
  - 之後可做設定存檔/重連、甚至本機 LAN server。

### 前置與常見卡點

- macOS / Windows 平台打包設定（路徑、icon、base url 等）
- Node 版本固定（20 LTS）

### 建議時程
2. build 出 dmg/exe
3. 設定資料：localStorage（先）/ 後續可加設定檔（房間 ID / 音量 / 顯示偏好）
4. （可選）本機 server 模式：一台當 host，另一台連 LAN